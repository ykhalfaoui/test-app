Voici un **super prompt** (copier‚Äìcoller) qui r√©sume tout ce qu‚Äôon a con√ßu. Il est en **fran√ßais**, puis en **anglais**. Tu peux le donner tel quel √† un(e) dev ou √† un autre LLM pour continuer le travail.

---

## üéØ Prompt (FR)

**Contexte & objectif**
Nous construisons une plateforme KYC modulaire (Spring Boot 3 / Java 17 / Spring Modulith) pour g√©rer :

* des **profils** (Party) et leurs **blocs KYC** versionn√©s (SCD Type 2),
* des **hits** (√©v√©nements) qui d√©clenchent des **instances de revue** (ReviewInstance),
* une **famille par instance** (ReviewMember) sans relation globale persist√©e,
* des **cibles de revue** (ReviewTarget) par (instance, personne, type de bloc),
* une **config** qui d√©finit les **blocs requis par type de relation** (RelationTypeBlockScope).
  Base de donn√©es cible : **Oracle** (H2 pour dev). Style √©v√©nementiel, **apr√®s commit** uniquement, avec **idempotence** et **retries**. Int√©grations (ex. Salesforce) via **outbox/eventing**.

---

### 1) Modules (Spring Modulith)

* `party` : entit√© Party + projection des statuts KYC (si besoin c√¥t√© technique).
* `blocks` : Block (par Party, Kind) + BlockVersion (SCD2) + vue `CurrentBlockV`.
* `hits` : r√©ception/qualification d‚Äôun hit ‚Üí publie `HitQualified`.
* `review` : d√©marre `ReviewInstance`, fige la famille (`ReviewMember`), cr√©e les `ReviewTarget`, ferme quand toutes les cibles sont termin√©es.
* `relations` : configuration des blocs requis par `relationType` via `RelationTypeBlockScope`.
* `integration` : √©coute les √©v√©nements (ex. `BlockVersionFinalized`, `ReviewClosed`) et pousse vers Salesforce (outbox + retry).
* `audit` : journalise transitions (domain events, erreurs).
* `kyc360` : vues de lecture (profil 360, famille, cibles, versions courantes).

**√âv√©nements internes** : utiliser `@ApplicationModuleListener` (modulith) + stockage JPA des √©v√©nements (outbox) pour **garantir apr√®s-commit** et **republication** au red√©marrage.

---

### 2) Mod√®le de donn√©es (simplifi√© c√¥t√© m√©tier)

* **Party**(id, externalRef, type, subType).
* **Block**(id, partyId, kind). Contrainte : **UNIQUE (partyId, kind)**.
* **BlockVersion**(id, blockId, versionNo, validFrom, validTo?, status, dataJson). SCD2 : **une seule courante** `validTo IS NULL`.

  * Facultatif (si on veut la contrainte directe) : ajouter `partyId`, `kind` et **UNIQUE(partyId, kind, versionNo)**.
* **Hit**(id, partyId, hitType, occurredAt, payloadJson).
* **ReviewInstance**(id, hitId?, pivotPartyId, startedAt, closedAt?, notes).
* **ReviewMember**(id, reviewId, memberPartyId, relationType, addedAt).

  * Remarque m√©tier : **pas de statuts agr√©g√©s** stock√©s au niveau Party/Review/Member dans les vues m√©tier simples.
* **ReviewTarget**(reviewId, targetPartyId, blockKind, blockVersionId?, state/finalStatus c√¥t√© technique).

  * PK logique : **(reviewId, targetPartyId, blockKind)**.
* **RelationTypeBlockScope**(relationType, blockKind, isRequired, policyCode?).

**Vues & index**

* `CurrentBlockV` (versions courantes) = `BlockVersion.validTo IS NULL`.
* Oracle : index unique fonctionnel pour ‚Äúune seule version courante‚Äù par `blockId`.

---

### 3) R√®gles & flux principaux

**A. D√©clenchement**

1. Un **Hit** qualifi√© (type X) arrive sur un Party pivot.
2. `review` cr√©e une **ReviewInstance** (si pas d√©j√† ouverte pour le cas d‚Äôusage), **fige la famille** : liste de `ReviewMember` (membres & `relationType`) **pour cette instance uniquement**.
3. Pour le pivot et chaque membre, on calcule les **blocs requis** via `RelationTypeBlockScope` et on cr√©e des **ReviewTarget** (un par blockKind requis).

**B. Gestion des Blocks (SCD2)**

* `ensureOpenVersion(partyId, kind)` :

  * s‚Äôil existe une version **en cours** (non finalis√©e) ‚Üí **r√©utiliser** (coalescer) ;
  * sinon, **clore** la courante (`validTo=now`) et **cr√©er** une nouvelle version `versionNo+1`.
* `applyInitialStatus` : selon les **inputs** du block, positionner un **statut initial** (ex. `APPROVED` automatique pour `STATIC_DATA`, sinon `PENDING_AGENT`).

**C. Avancement de la revue**

* Quand un block est finalis√© ‚Üí publier `BlockVersionFinalized(blockVersionId, partyId, kind, finalStatus)`.
* `review` marque la **ReviewTarget** correspondante comme **DONE** (idempotent) et **ferme l‚Äôinstance** quand `remaining=0`.
* **Per-relation review status** (si n√©cessaire c√¥t√© technique) = agr√©gat des `ReviewTarget` du **membre** sur les **kinds requis** (r√®gle d‚Äôordre : `REJECTED > PENDING > APPROVED`).

  * NB : pour le **m√©tier**, on peut pr√©senter une **vue sans ces statuts** (demand√©), mais la m√©canique existe techniquement.

**D. Concurrence & idempotence**

* Contrainte d‚Äôunicit√© **(party, kind)** sur `Block`.
* Une seule **version courante** par block (index unique partiel/fonctionnel).
* `ReviewTarget` est idempotent via sa **PK logique**.
* √âcoutes via `@ApplicationModuleListener` (apr√®s commit), **retries** automatiques modulith + outbox.
* En cas de deux updates simultan√©s de blocks diff√©rents, `review` recalcule la fermeture apr√®s chaque `BlockVersionFinalized`.

---

### 4) Int√©gration & erreurs

* **Salesforce** : √©couter `BlockVersionFinalized(APPROVED)`, `ReviewClosed`, √©ventuellement changements Party.

  * **Idempotence** externe (cl√© : `party.externalRef`, `blockKind`, `versionNo`).
  * **Outbox** + retry + DLQ ; loguer dans **ELK** et renvoyer un **Event d‚Äô√©chec** (observable).
* **Audit** : journaliser transitions (domain events), entr√©es/sorties d‚Äôint√©gration, erreurs ; √©viter l‚ÄôAOP ‚Äúmagique‚Äù, pr√©f√©rer des **listeners** explicites ou des **entity listeners** cibl√©s.

---

### 5) API (MVP)

* `POST /api/hits/qualified { partyId, hitType }` ‚Üí cr√©e hit qualifi√© ‚Üí d√©marre la review.
* `GET /api/reviews/{id}` ‚Üí vue 360 de l‚Äôinstance (pivot, membres, targets, blocs courants).
* `GET /api/parties/{id}/kyc360` ‚Üí vue lecture : blocks courants + membres (sans statuts agr√©g√©s si demand√© au m√©tier).

---

### 6) √Ä produire (automatisable)

* **Diagrammes PlantUML** :

  * *Class diagram (m√©tier simple, sans statuts)*,
  * *ERD*,
  * *Sequence (Hit‚ÜíReview‚ÜíBlocks‚ÜíTargets‚ÜíFinalize‚ÜíClose)*,
  * *Component/Package (modulith)*.
* **DDL Oracle & H2** (avec vue `CurrentBlockV`, index d‚Äôunicit√©).
* **Projet Spring Boot** (modules, listeners, services SCD2, endpoints de base).
* **Jeux de tests** : coalescence de version, double hit, famille large (400+ membres), retries int√©gration, idempotence.

**Contraintes non-fonctionnelles**

* Java 17, Spring Boot 3.3+, Spring Modulith (events JPA), H2 dev / Oracle prod.
* Transactions : publier les events **apr√®s commit** seulement.
* Observabilit√© : logs structur√©s, corr√©lation par `reviewId` / `hitId`.

---

## üéØ Prompt (EN)

**Context & goal**
Build a modular KYC platform (Spring Boot 3 / Java 17 / Spring Modulith) to manage:

* **Profiles** (Party) and **versioned KYC blocks** (SCD Type 2),
* **Hits** that trigger **ReviewInstances**,
* **Per-instance family** (ReviewMember) with no global relation table,
* **ReviewTargets** per (instance, person, blockKind),
* **Config** defining required block kinds per relation type (RelationTypeBlockScope).
  Target DB: **Oracle** (H2 for dev). Event-driven, **after-commit** only, **idempotent** with **retries**. Integrations (e.g., Salesforce) via **outbox/eventing**.

\[Repeat the same 6 sections in English mirroring the French content‚Äîmodules, data model, rules/flows, integration & errors, APIs, deliverables & NFRs.]

---

Si tu veux, je peux te livrer ce prompt **en fichier texte** ou **l‚Äôint√©grer** dans le README du projet existant.
