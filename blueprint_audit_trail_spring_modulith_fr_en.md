# ðŸ” Blueprint Complet â€“ Audit Trail pour Spring Modulith (FR/EN)

> **Contexte** : Application KYC Remediation (Java + Spring Modulith, JPA/Oracle, ELK/OpenSearch, intÃ©gration Salesforce pour logs dâ€™erreur). Audit 100% applicatif. Ã‰vÃ©nements publiÃ©s **aprÃ¨s commit** via Publication Registry. Listeners asynchrones, rÃ©-exÃ©cutables (retry) en cas dâ€™Ã©chec.

---

## ðŸ‡«ðŸ‡· Partie A â€” SpÃ©cification (FR)

### 1) Objectifs & Contraintes
- **Tracer** : Ã©vÃ©nements mÃ©tier/app, actions sensibles, erreurs critiques.
- **PortÃ©e** : audit **in-app** (base locale) + **projection logs** vers ELK/OpenSearch.
- **Gestion des erreurs Salesforce** : si lâ€™audit Ã©choue, log **outbox** vers Salesforce (rejouable, rÃ©silient).
- **Spring Modulith** : publication **AFTER_COMMIT** + **Publication Registry** pour retries.
- **Contexte** : conserver lâ€™identitÃ© utilisateur, rÃ´les, tenant, IDs de corrÃ©lation **mÃªme en async/retry**.
- **ConformitÃ©** : masquage PII, immutabilitÃ© logique, rÃ©tention, RBAC.

### 2) Architecture Modulaire (Spring Modulith)
```
audit-core/        -> ModÃ¨les (AuditEntry, AuditContext), services, exceptions
audit-spi/         -> Ports: AuditStorage, AuditSink, PayloadRedactor, ContextEnricher
audit-jpa/         -> Adaptateur JPA (Oracle) + REQUIRES_NEW
audit-log/         -> Logger JSON structurÃ© (Logback -> ELK/OpenSearch)
audit-ingest/      -> Listeners @ApplicationModuleListener + AOP @Audited
audit-api/         -> (Optionnel) API GET/POST /audit-entries
sf-outbox/         -> Outbox Salesforce + sender + retries
infra-async/       -> Config @Async (Security + MDC TaskDecorator)
infra-context/     -> MDC, CorrelationFilter, Contexts.snapshot()
```

### 3) ModÃ¨le de DonnÃ©es
**Table audit (unique app)**
```sql
CREATE TABLE audit_entry (
  id               NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ts_utc           TIMESTAMP WITH TIME ZONE NOT NULL,
  event_type       VARCHAR2(128) NOT NULL,
  severity         VARCHAR2(16)  NOT NULL,
  user_id          VARCHAR2(128),
  roles            VARCHAR2(512),
  tenant_id        VARCHAR2(64),
  correlation_id   VARCHAR2(128),
  request_id       VARCHAR2(128),
  source           VARCHAR2(64),
  subject_type     VARCHAR2(128),
  subject_id       VARCHAR2(256),
  payload_json     CLOB CHECK (payload_json IS JSON),
  signature_hash   VARCHAR2(128)
);
CREATE INDEX idx_audit_ts   ON audit_entry(ts_utc);
CREATE INDEX idx_audit_corr ON audit_entry(correlation_id);
```

**Table outbox Salesforce**
```sql
CREATE TABLE salesforce_outbox (
  id           NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at   TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
  type         VARCHAR2(64) NOT NULL,
  payload_json CLOB CHECK (payload_json IS JSON) NOT NULL,
  status       VARCHAR2(16) DEFAULT 'NEW' CHECK (status IN ('NEW','SENT','FAILED')) NOT NULL,
  attempts     NUMBER DEFAULT 0 NOT NULL,
  last_error   CLOB
);
CREATE INDEX idx_sf_status ON salesforce_outbox(status);
```

### 4) Contrats (Core)
```java
public record AuditContext(String userId, List<String> roles, String tenantId,
                           String correlationId, String requestId) {}

public record AuditEntry(Instant tsUtc, String eventType, String severity,
                         String subjectType, String subjectId,
                         AuditContext ctx, JsonNode payload) {}

public record Envelope<T>(AuditContext ctx, String type, T payload) {}
```

### 5) Contexte & Propagation (Web â†’ Async â†’ Retry)
- **Snapshot** : capturer `SecurityContext` + `MDC` au **moment de lâ€™Ã©mission** (dans la transaction mÃ©tier).
- **Enveloppe** : inclure **AuditContext** dans chaque Ã©vÃ©nement.
- **RÃ©installation** : au dÃ©but des listeners, restaurer `SecurityContext` + `MDC` depuis lâ€™enveloppe.
- **@Async** : exÃ©cuteur dÃ©corÃ© `DelegatingSecurityContextAsyncTaskExecutor` + `TaskDecorator` pour MDC.

**Config Async**
```java
@EnableAsync
@Configuration
class AsyncConfig {
  @Bean TaskDecorator mdcTaskDecorator() { /* copie MDC comme montrÃ© */ }
  @Bean(name = "auditExecutor")
  AsyncTaskExecutor auditExecutor(TaskDecorator td) {
    var t = new ThreadPoolTaskExecutor();
    t.setCorePoolSize(4); t.setMaxPoolSize(16); t.setQueueCapacity(1000);
    t.setThreadNamePrefix("audit-"); t.setTaskDecorator(td); t.initialize();
    return new DelegatingSecurityContextAsyncTaskExecutor(t);
  }
}
```

**Snapshot**
```java
final class Contexts {
  static AuditContext snapshot() {
    var auth = SecurityContextHolder.getContext().getAuthentication();
    var user  = (auth != null ? auth.getName() : "anonymous");
    var roles = (auth != null ? auth.getAuthorities().stream().map(a->a.getAuthority()).toList() : List.of());
    return new AuditContext(user, roles, MDC.get("tenantId"), MDC.get("correlationId"), MDC.get("requestId"));
  }
}
```

### 6) Publication dâ€™Ã‰vÃ©nements (After Commit)
```java
@Service
class PartyService {
  private final ApplicationEventPublisher publisher;

  @Transactional
  public void updateParty(String partyId, UpdateDto dto) {
    // ... persistance
    publisher.publishEvent(new Envelope<>(
      Contexts.snapshot(), "PARTY_UPDATED", new PartyUpdated(partyId, dto.changes())));
  }
}
```

### 7) Listeners Audit (AOP + Event)
**Annotation & Aspect (survivre aux rollbacks via NEW TX)**
```java
@Target(METHOD) @Retention(RUNTIME)
public @interface Audited { String action(); String subjectType() default ""; String subjectIdExpr() default ""; }

@Aspect @Component
class AuditedAspect {
  private final AuditService audit; private final SalesforceOutboxService sf;

  @Around("@annotation(a)")
  Object around(ProceedingJoinPoint pjp, Audited a) throws Throwable {
    var ctx = Contexts.snapshot();
    try { return pjp.proceed(); }
    catch (Exception ex) {
      audit.recordErrorNewTx(ctx, a.action(), subjectFrom(pjp, a), ex);
      sf.enqueueNewTx("AuditError", payload(ctx, a, ex));
      throw ex;
    }
  }
}
```

**Listener Modulith (rÃ©installation contexte)**
```java
@Component
class AuditListener {
  private final AuditService audit; private final SalesforceOutboxService sf;

  @Async("auditExecutor")
  @ApplicationModuleListener
  void on(Envelope<PartyUpdated> e) {
    runWithSecurityAndMdc(e.ctx(), () -> {
      try {
        audit.recordInfoNewTx(e.ctx(), e.type(), "Party", e.payload().partyId(), toJson(e.payload()));
      } catch (Exception ex) {
        audit.recordErrorNewTx(e.ctx(), e.type(), "Party", e.payload().partyId(), ex);
        sf.enqueueNewTx("AuditError", Map.of(
          "correlationId", e.ctx().correlationId(),
          "userId", e.ctx().userId(),
          "tenantId", e.ctx().tenantId(),
          "eventType", e.type(),
          "partyId", e.payload().partyId(),
          "message", ex.getMessage()));
        throw ex; // laisser la publication incomplÃ¨te pour retry
      }
    });
  }
}
```

### 8) Persistance (REQUIRES_NEW)
```java
@Service
class AuditService {
  private final AuditEntryRepository repo; private final Logger auditLogger = LoggerFactory.getLogger("AUDIT");

  @Transactional(propagation = REQUIRES_NEW)
  public void recordInfoNewTx(AuditContext ctx, String evt, String st, String sid, JsonNode payload) {
    var entry = new AuditEntry(Instant.now(), evt, "INFO", st, sid, ctx, payload);
    repo.save(entry); auditLogger.info(structured(entry));
  }

  @Transactional(propagation = REQUIRES_NEW)
  public void recordErrorNewTx(AuditContext ctx, String evt, String st, String sid, Exception ex) {
    var payload = toJson(Map.of("error", ex.getMessage()));
    var entry = new AuditEntry(Instant.now(), evt, "ERROR", st, sid, ctx, payload);
    repo.save(entry); auditLogger.warn(structured(entry));
  }
}
```

### 9) IntÃ©gration Salesforce (Outbox)
- **Why** : dÃ©coupler et garantir la livraison mÃªme si Salesforce est indisponible.
- **Comment** : table `salesforce_outbox` + job `@Scheduled` pour flush avec retries.

```java
@Component
class SalesforceOutboxJob {
  @Scheduled(fixedDelay = 15000)
  @Transactional
  public void flush() { /* lockNextBatch -> sender -> markSent/Failed */ }
}
```

### 10) Logging StructurÃ© â†’ ELK/OpenSearch
- **Logback** : appender JSON (Logstash TCP/HTTP).
- **ClÃ©s ECS-like** : `event.type`, `user.id`, `tenant.id`, `trace.correlation_id`, `audit=true`.
- **Dashboards** : Activity, Sensitive Changes, Errorâ†’Audit par `correlation_id`.

### 11) SÃ©curitÃ©, PII & RÃ©tention
- **RBAC** : `AUDIT_READ` / `AUDIT_WRITE`.
- **Masquage PII** : `PayloadRedactor` (regex/annotations `@Sensitive`).
- **RÃ©tention** : purge DB (90j) + ISM/ILM index cÃ´tÃ© OpenSearch (12â€“36 mois).
- **ImmutabilitÃ©** : pas dâ€™UPDATE, uniquement INSERT.

### 12) Tests & OpÃ©rations
- **Unitaires** : Aspect, Contexts.snapshot, Redactor.
- **Modulaires** : `@ApplicationModuleListener` + Publication Registry retry.
- **Contrats** : API audit.
- **Charge** : batch insert, appender JSON.
- **Runbook** :
  - vÃ©rifier publications incomplÃ¨tes Modulith,
  - relancer listeners,
  - surveiller outbox Salesforce (FAILED/attempts),
  - dashboards ELK (latence, volume, erreurs).

---

## ðŸ‡¬ðŸ‡§ Part B â€” Specification (EN)

### 1) Goals & Constraints
- **Trace** domain/app events, sensitive operations, critical errors.
- **Scope**: inâ€‘app audit (local DB) + **structured logs** to ELK/OpenSearch.
- **Salesforce on error**: if audit fails, enqueue **Salesforce outbox** (retriable).
- **Spring Modulith**: events **AFTER_COMMIT** + **Publication Registry** for retries.
- **Context**: preserve user/roles/tenant/correlation across **async & retries**.
- **Compliance**: PII masking, logical immutability, retention, RBAC.

### 2) Modular Architecture (Spring Modulith)
_Identical to FR section; see module list above._

### 3) Data Model
_See FR SQL. Replace types if using PostgreSQL/others._

### 4) Contracts (Core)
_See FR `AuditContext`, `AuditEntry`, `Envelope<T>`._

### 5) Context Propagation (Web â†’ Async â†’ Retry)
- Take a **snapshot** at emission time.
- **Embed** `AuditContext` in every event.
- **Reinstall** SecurityContext + MDC in listeners.
- Use `DelegatingSecurityContextAsyncTaskExecutor` + MDC `TaskDecorator`.

### 6) Event Emission (After Commit)
_Same pattern as FR._

### 7) Audit Listeners (AOP + Event)
- **AOP** to catch failures and write audit/outbox in **`REQUIRES_NEW`**.
- **Event listener** restores context from envelope; throws on failure to keep publication **incomplete** for retry.

### 8) Persistence (REQUIRES_NEW)
- Separate transaction ensures audit survives business rollbacks and listener failures.

### 9) Salesforce Integration (Outbox)
- Durable, decoupled delivery with scheduled retries and circuit breaker.

### 10) Structured Logging â†’ ELK/OpenSearch
- Logback JSON appender; ECS-like keys; ready-to-use dashboards.

### 11) Security, PII, Retention
- RBAC, masking/redaction, retention policies, no updates on audit rows.

### 12) Testing & Ops
- Unit, modular, contract, load.
- Runbook for Modulith incomplete publications & Salesforce outbox.

---

## ðŸ“¦ Annexes â€” Snippets & Config

### A. `logback-spring.xml` (extrait)
```xml
<configuration>
  <appender name="LOGSTASH" class="net.logstash.logback.appender.LogstashTcpSocketAppender">
    <destination>logstash:5044</destination>
    <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder"/>
  </appender>
  <logger name="AUDIT" level="INFO" additivity="false">
    <appender-ref ref="LOGSTASH"/>
  </logger>
</configuration>
```

### B. Checklist de Mise en Å’uvre
- [ ] Snapshot de contexte Ã  lâ€™Ã©mission.
- [ ] Enveloppe avec `AuditContext`.
- [ ] Listener â†’ rÃ©installer contexte.
- [ ] Ã‰critures audit + outbox en `REQUIRES_NEW`.
- [ ] Appender JSON vers ELK/OpenSearch.
- [ ] PII redaction + RBAC.
- [ ] RÃ©tention DB + ILM/ISM indices.
- [ ] Tests retry Publication Registry.
- [ ] Dashboards prÃªts (Activity, Sensitive, Errors).

### C. Variantes
- **Table par module** si ownership strict.
- **CDC (Debezium)** pour ingestion vers data lake.
- **Chiffrement colonne** pour `payload_json` si requis.

---

> **Livrables fournis ici** : plan FR/EN, contrats, patterns (events, AOP, async), snippets clÃ©s. Ã€ adapter Ã  vos conventions de package et de nommage.



---

## âœï¸ Documentation dÃ©taillÃ©e du code (FR)

### ðŸ”Ž Politique AOP â€” fautâ€‘il logger aussi en cas de succÃ¨s ?
**Recommandation par dÃ©faut (contexte Spring Modulith + Publication Registry)** :
- **AOP = Ã©chec uniquement** (moins de bruit, pas de faux positifs si la Tx rollback ensuite).
- **SuccÃ¨s = via Ã©vÃ©nements afterâ€‘commit** (garantis seulement lorsque la Tx a effectivement **commit**).

**Alternatives (si besoin mÃ©tier)** :
1) **AOP succÃ¨s + Ã©chec** mais **dÃ©fÃ©rÃ© aprÃ¨s outcome** : on Ã©crit lâ€™audit depuis lâ€™AOP **aprÃ¨s** avoir su si la Tx a commit/rollback, via `TransactionSynchronization.afterCompletion(...)`, et on persiste en `REQUIRES_NEW`.
2) **Flag par annotation** : `@Audited(logOnSuccess = true)` active ce mode uniquement sur certaines mÃ©thodes.

```java
@Target(METHOD)
@Retention(RUNTIME)
public @interface Audited {
  String action();
  String subjectType() default "";
  String subjectIdExpr() default ""; // ex: "#partyId"
  boolean logOnSuccess() default false; // â‡ optionnel : succÃ¨s via AOP
}

@Aspect @Component
class AuditedAspect {
  private final AuditService audit; private final SalesforceOutboxService sf;

  @Around("@annotation(a)")
  Object around(ProceedingJoinPoint pjp, Audited a) throws Throwable {
    var ctx = Contexts.snapshot();
    var subjectType = a.subjectType();
    var subjectId   = evalSubjectId(pjp, a.subjectIdExpr());

    // Si on veut aussi tracer le succÃ¨s via AOP, sâ€™abonner au cycle Tx
    if (a.logOnSuccess()) {
      TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() {
        @Override public void afterCompletion(int status) {
          if (status == STATUS_COMMITTED) {
            audit.recordInfoNewTx(ctx, a.action(), subjectType, subjectId, json(Map.of("aop","success")));
          }
        }
      });
    }

    try {
      return pjp.proceed();
    } catch (Exception ex) {
      audit.recordErrorNewTx(ctx, a.action(), subjectType, subjectId, ex); // survit au rollback
      sf.enqueueNewTx("AuditError", Map.of(
        "correlationId", ctx.correlationId(),
        "userId", ctx.userId(),
        "tenantId", ctx.tenantId(),
        "action", a.action(),
        "subjectType", subjectType,
        "subjectId", subjectId,
        "message", ex.getMessage()
      ));
      throw ex;
    }
  }
  // ... evalSubjectId(...) identique
}
```

> **TL;DR** : garde **AOP pour les erreurs** (fiable, sobre). Si un besoin impose le succÃ¨s via AOP, utilise **afterCompletion** pour nâ€™Ã©crire quâ€™aprÃ¨s connaissance de lâ€™issue, et toujours en **`REQUIRES_NEW`**.

### A) Annotation & Aspect AOP â€” *loguer uniquement en cas dâ€™erreur*
> **But** : ne pas Â« bruiter Â» lâ€™audit en AOP. Lâ€™AOP ne **loggue** quâ€™en **Ã©chec**, pour garantir une trace mÃªme si la transaction mÃ©tier a rollback. Les **succÃ¨s** sont gÃ©rÃ©s par les **Ã©vÃ©nements** (listeners aprÃ¨s commit) afin de rester modulaires et cohÃ©rents avec Spring Modulith.

```java
/**
 * Marque une mÃ©thode comme sensible du point de vue audit.
 * - action: nom canonique de lâ€™action (ex: "UPDATE_PARTY")
 * - subjectType: type logique de la cible (ex: "Party")
 * - subjectIdExpr: SpEL pour extraire lâ€™identifiant (ex: "#partyId")
 */
@Target(METHOD)
@Retention(RUNTIME)
public @interface Audited {
  String action();
  String subjectType() default "";
  String subjectIdExpr() default ""; // ex: "#partyId"
}

/**
 * Aspect dâ€™audit minimaliste.
 *
 * âœ” Capture un snapshot du contexte (user/roles/tenant/correlationId).
 * âœ” Si la mÃ©thode Ã©choue, Ã©crit un audit **en nouvelle transaction** (REQUIRES_NEW)
 *   pour survivre au rollback mÃ©tier + enfile un message outbox Salesforce.
 * âœ– Ne loggue rien en cas de succÃ¨s (on laisse les events le faire aprÃ¨s commit).
 */
@Aspect
@Component
class AuditedAspect {
  private final AuditService audit;            // persistance audit en NEW TX
  private final SalesforceOutboxService sf;    // outbox Salesforce en NEW TX
  private final SpelExpressionParser spel = new SpelExpressionParser();

  AuditedAspect(AuditService audit, SalesforceOutboxService sf) {
    this.audit = audit; this.sf = sf;
  }

  @Around("@annotation(a)")
  Object around(ProceedingJoinPoint pjp, Audited a) throws Throwable {
    var ctx = Contexts.snapshot(); // user/roles/tenant/correlationId/requestId
    String subjectType = a.subjectType();
    String subjectId   = evalSubjectId(pjp, a.subjectIdExpr());

    try {
      return pjp.proceed();
    } catch (Exception ex) {
      // 1) Ã‰criture dâ€™audit dâ€™erreur en **nouvelle transaction**
      audit.recordErrorNewTx(ctx, a.action(), subjectType, subjectId, ex);

      // 2) Outbox Salesforce (rejouable, dÃ©couplÃ©)
      sf.enqueueNewTx("AuditError", Map.of(
        "correlationId", ctx.correlationId(),
        "userId", ctx.userId(),
        "tenantId", ctx.tenantId(),
        "action", a.action(),
        "subjectType", subjectType,
        "subjectId", subjectId,
        "message", ex.getMessage()
      ));

      // 3) Propager lâ€™erreur pour que lâ€™appelant sache quâ€™il y a Ã©chec
      throw ex;
    }
  }

  private String evalSubjectId(ProceedingJoinPoint pjp, String expr) {
    if (expr == null || expr.isBlank()) return null;
    var method = ((MethodSignature) pjp.getSignature()).getMethod();
    var ctx = new StandardEvaluationContext(new MethodBasedEvaluationContext(null, method, pjp.getArgs(), new DefaultParameterNameDiscoverer()));
    var parsed = spel.parseExpression(expr);
    var val = parsed.getValue(ctx);
    return (val != null ? String.valueOf(val) : null);
  }
}
```

**Pourquoi ce choix ?**
- En **succÃ¨s**, la vÃ©ritÃ© vient des **Ã©vÃ©nements aprÃ¨s commit** (Publication Registry + retries). 
- En **Ã©chec**, seule lâ€™AOP, dÃ©clenchÃ©e *dans le flot de lâ€™exception*, peut garantir un **audit persistant** (NEW TX) + un **signal Salesforce**.

---

### B) Listeners dâ€™Ã©vÃ©nements â€” *succÃ¨s aprÃ¨s commit, retries gÃ©rÃ©s par Modulith*

```java
/** EvÃ©nement enveloppÃ© avec le contexte dâ€™audit figÃ© au moment de lâ€™Ã©mission. */
public record Envelope<T>(AuditContext ctx, String type, T payload) {}

/** Exemple dâ€™Ã©mission dans une transaction mÃ©tier. */
@Service
class PartyService {
  private final ApplicationEventPublisher publisher;
  @Transactional
  public void updateParty(String partyId, UpdateDto dto) {
    // ... persistance JPA
    publisher.publishEvent(new Envelope<>(
      Contexts.snapshot(), "PARTY_UPDATED", new PartyUpdated(partyId, dto.changes())));
  }
}

/** Listener asynchrone : restaure le contexte et Ã©crit en NEW TX. */
@Component
class AuditListener {
  private final AuditService audit; private final SalesforceOutboxService sf;

  @Async("auditExecutor")
  @ApplicationModuleListener
  void on(Envelope<PartyUpdated> e) {
    runWithSecurityAndMdc(e.ctx(), () -> {
      try {
        audit.recordInfoNewTx(e.ctx(), e.type(), "Party", e.payload().partyId(), toJson(e.payload()));
      } catch (Exception ex) {
        // Echec du listener => garder publication incomplÃ¨te (retry) **et** tracer lâ€™Ã©chec
        audit.recordErrorNewTx(e.ctx(), e.type(), "Party", e.payload().partyId(), ex);
        sf.enqueueNewTx("AuditError", Map.of(
          "correlationId", e.ctx().correlationId(),
          "userId", e.ctx().userId(),
          "tenantId", e.ctx().tenantId(),
          "eventType", e.type(),
          "partyId", e.payload().partyId(),
          "message", ex.getMessage()
        ));
        throw ex; // permet Ã  Spring Modulith de rejouer plus tard
      }
    });
  }
}
```

---

## ðŸ—ƒï¸ ModÃ¨le de donnÃ©es â€” Documentation (FR)

### Table `audit_entry`
**RÃ´le** : journal applicatif persistant et immuable (INSERTâ€‘only). Les succÃ¨s proviennent surtout des **listeners afterâ€‘commit** ; les erreurs peuvent venir de lâ€™**AOP** (NEWÂ TX) ou des listeners.

| Colonne | Type | Obligatoire | Exemple | Contraintes/Notes |
|---|---|---:|---|---|
| `id` | NUMBER (IDENTITY) | âœ” | `102934` | PK technique ; pas rÃ©utilisÃ©e. |
| `ts_utc` | TIMESTAMP WITH TIME ZONE | âœ” | `2025-09-25T10:11:12Z` | Utiliser `Clock` pour tests ; indexÃ©. |
| `event_type` | VARCHAR2(128) | âœ” | `PARTY_UPDATED` | Nommage constant (enum/const) ; indexÃ©. |
| `severity` | VARCHAR2(16) | âœ” | `INFO`/`ERROR` | Valeurs : `INFO`,`WARN`,`ERROR`,`SECURITY`. |
| `user_id` | VARCHAR2(128) |  | `alice` | `anonymous` si inconnu ; ne pas stocker PII non nÃ©cessaire. |
| `roles` | VARCHAR2(512) |  | `ROLE_ADMIN,ROLE_USER` | Peut Ãªtre JSON si besoin multiâ€‘valeurs riche. |
| `tenant_id` | VARCHAR2(64) |  | `lux` | Pour routing multiâ€‘tenant et filtres Kibana. |
| `correlation_id` | VARCHAR2(128) |  | `c-2d1f...` | PropagÃ© via MDC ; **clÃ© de jointure** avec logs applicatifs. |
| `request_id` | VARCHAR2(128) |  | `r-9ab7...` | GranularitÃ© intraâ€‘requÃªte ; utile en debug. |
| `source` | VARCHAR2(64) |  | `API`/`EVENT` | Origine : `API`/`SERVICE`/`EVENT`/`BATCH`/`KAFKA`â€¦ |
| `subject_type` | VARCHAR2(128) |  | `Party` | Type mÃ©tier visÃ© ; utile pour pivot. |
| `subject_id` | VARCHAR2(256) |  | `P12345` | Identifiant mÃ©tier cible ; attention aux tailles. |
| `payload_json` | CLOB (JSON) | âœ” | `{ "oldRole":"CLIENT","newRole":"THIRD_PARTY" }` | **Redaction PII** obligatoire ; rester concis. |
| `signature_hash` | VARCHAR2(128) |  | `HMAC-SHA256(...)` | IntÃ©gritÃ© optionnelle (HMAC sur payload+meta). |

**Index conseillÃ©s**
- `(ts_utc)` pour les recherches temporelles.
- `(event_type)` pour les filtres fonctionnels.
- `(correlation_id)` pour la corrÃ©lation.
- Facultatif : `(tenant_id, ts_utc)` si multiâ€‘tenant volumineux.

**Idempotence (option)**
- Contrainte logique `(event_type, subject_id, request_id)` si rejouabilitÃ© possible.

**PII & sÃ©curitÃ©**
- Masquer/Ã©liminer les PII dans `payload_json` (`PayloadRedactor`).
- Ne journaliser que ce qui est **utile** au support et Ã  la conformitÃ©.

### Table `salesforce_outbox`
**RÃ´le** : file durable pour notifier Salesforce des erreurs (ou signaux dâ€™audit critiques) avec retries.

| Colonne | Type | Obligatoire | Exemple | Notes |
|---|---|---:|---|---|
| `id` | NUMBER (IDENTITY) | âœ” | `7781` | PK |
| `created_at` | TIMESTAMPTZ | âœ” | `2025-09-25T10:11:30Z` | Rollover et mÃ©triques de dÃ©lai. |
| `type` | VARCHAR2(64) | âœ” | `AuditError` | Type logique stable pour mapping SF. |
| `payload_json` | CLOB (JSON) | âœ” | `{ ... }` | Minimal, actionnable (corrId, message, ids). |
| `status` | VARCHAR2(16) | âœ” | `NEW` | Enum : `NEW`/`SENT`/`FAILED`; indexÃ©. |
| `attempts` | NUMBER | âœ” | `3` | Pour backoff exponentiel. |
| `last_error` | CLOB |  | `Timeout` | DerniÃ¨re raison dâ€™Ã©chec.

**Flux**
1) `enqueueNewTx(...)` insÃ¨re.
2) `@Scheduled` lit `status=NEW` par lot.
3) Envoi â†’ `SENT` ou `FAILED`; plan de retry.

## ðŸ‡¬ðŸ‡§ Notes (EN) â€” What changed vs. previous version
- Added **AOP policy** (errorâ€‘only by default, optional success via `afterCompletion`).
- Expanded **columnâ€‘level documentation** with examples, constraints and indexing hints.
 (EN) â€” What changed vs. previous version
- **AOP clarified**: it writes **only on failure**, in a **new transaction**; success path is left to **afterâ€‘commit events**.
- **Data model documented** with columnâ€‘byâ€‘column rationale and ops tips.
- **Comments** added to all code snippets to make intent explicit.

> Besoin dâ€™exemples supplÃ©mentaires (tests, `logback`, redactor PII, ou requÃªtes SQL dâ€™archivage) ? Je peux les ajouter juste en dessous.

