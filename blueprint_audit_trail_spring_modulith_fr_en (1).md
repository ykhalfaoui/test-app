# üîê Blueprint Complet ‚Äì Audit Trail pour Spring Modulith (FR/EN)

> **Contexte** : Application KYC Remediation (Java + Spring Modulith, JPA/Oracle, ELK/OpenSearch, int√©gration Salesforce pour logs d‚Äôerreur). Audit 100% applicatif. √âv√©nements publi√©s **apr√®s commit** via Publication Registry. Listeners asynchrones, r√©-ex√©cutables (retry) en cas d‚Äô√©chec.

---

## üá´üá∑ Partie A ‚Äî Sp√©cification (FR)

### 1) Objectifs & Contraintes
- **Tracer** : √©v√©nements m√©tier/app, actions sensibles, erreurs critiques.
- **Port√©e** : audit **in-app** (base locale) + **projection logs** vers ELK/OpenSearch.
- **Gestion des erreurs Salesforce** : si l‚Äôaudit √©choue, log **outbox** vers Salesforce (rejouable, r√©silient).
- **Spring Modulith** : publication **AFTER_COMMIT** + **Publication Registry** pour retries.
- **Contexte** : conserver l‚Äôidentit√© utilisateur, r√¥les, tenant, IDs de corr√©lation **m√™me en async/retry**.
- **Conformit√©** : masquage PII, immutabilit√© logique, r√©tention, RBAC.

### 2) Architecture Modulaire (Spring Modulith)
```
audit-core/        -> Mod√®les (AuditEntry, AuditContext), services, exceptions
audit-spi/         -> Ports: AuditStorage, AuditSink, PayloadRedactor, ContextEnricher
audit-jpa/         -> Adaptateur JPA (Oracle) + REQUIRES_NEW
audit-log/         -> Logger JSON structur√© (Logback -> ELK/OpenSearch)
audit-ingest/      -> Listeners @ApplicationModuleListener + AOP @Audited
audit-api/         -> (Optionnel) API GET/POST /audit-entries
sf-outbox/         -> Outbox Salesforce + sender + retries
infra-async/       -> Config @Async (Security + MDC TaskDecorator)
infra-context/     -> MDC, CorrelationFilter, Contexts.snapshot()
```

### 3) Mod√®le de Donn√©es
**Table audit (unique app)**
```sql
CREATE TABLE audit_entry (
  id               NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ts_utc           TIMESTAMP WITH TIME ZONE NOT NULL,
  event_type       VARCHAR2(128) NOT NULL,
  severity         VARCHAR2(16)  NOT NULL,
  user_id          VARCHAR2(128),
  roles            VARCHAR2(512),
  tenant_id        VARCHAR2(64),
  correlation_id   VARCHAR2(128),
  request_id       VARCHAR2(128),
  source           VARCHAR2(64),
  subject_type     VARCHAR2(128),
  subject_id       VARCHAR2(256),
  payload_json     CLOB CHECK (payload_json IS JSON),
  signature_hash   VARCHAR2(128)
);
CREATE INDEX idx_audit_ts   ON audit_entry(ts_utc);
CREATE INDEX idx_audit_corr ON audit_entry(correlation_id);
```

**Table outbox Salesforce**
```sql
CREATE TABLE salesforce_outbox (
  id           NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at   TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
  type         VARCHAR2(64) NOT NULL,
  payload_json CLOB CHECK (payload_json IS JSON) NOT NULL,
  status       VARCHAR2(16) DEFAULT 'NEW' CHECK (status IN ('NEW','SENT','FAILED')) NOT NULL,
  attempts     NUMBER DEFAULT 0 NOT NULL,
  last_error   CLOB
);
CREATE INDEX idx_sf_status ON salesforce_outbox(status);
```

### 4) Contrats (Core)
```java
public record AuditContext(String userId, List<String> roles, String tenantId,
                           String correlationId, String requestId) {}

public record AuditEntry(Instant tsUtc, String eventType, String severity,
                         String subjectType, String subjectId,
                         AuditContext ctx, JsonNode payload) {}

public record Envelope<T>(AuditContext ctx, String type, T payload) {}
```

### 5) Contexte & Propagation (Web ‚Üí Async ‚Üí Retry)
- **Snapshot** : capturer `SecurityContext` + `MDC` au **moment de l‚Äô√©mission** (dans la transaction m√©tier).
- **Enveloppe** : inclure **AuditContext** dans chaque √©v√©nement.
- **R√©installation** : au d√©but des listeners, restaurer `SecurityContext` + `MDC` depuis l‚Äôenveloppe.
- **@Async** : ex√©cuteur d√©cor√© `DelegatingSecurityContextAsyncTaskExecutor` + `TaskDecorator` pour MDC.

**Config Async**
```java
@EnableAsync
@Configuration
class AsyncConfig {
  @Bean TaskDecorator mdcTaskDecorator() { /* copie MDC comme montr√© */ }
  @Bean(name = "auditExecutor")
  AsyncTaskExecutor auditExecutor(TaskDecorator td) {
    var t = new ThreadPoolTaskExecutor();
    t.setCorePoolSize(4); t.setMaxPoolSize(16); t.setQueueCapacity(1000);
    t.setThreadNamePrefix("audit-"); t.setTaskDecorator(td); t.initialize();
    return new DelegatingSecurityContextAsyncTaskExecutor(t);
  }
}
```

**Snapshot**
```java
final class Contexts {
  static AuditContext snapshot() {
    var auth = SecurityContextHolder.getContext().getAuthentication();
    var user  = (auth != null ? auth.getName() : "anonymous");
    var roles = (auth != null ? auth.getAuthorities().stream().map(a->a.getAuthority()).toList() : List.of());
    return new AuditContext(user, roles, MDC.get("tenantId"), MDC.get("correlationId"), MDC.get("requestId"));
  }
}
```

### 6) Publication d‚Äô√âv√©nements (After Commit)
```java
@Service
class PartyService {
  private final ApplicationEventPublisher publisher;

  @Transactional
  public void updateParty(String partyId, UpdateDto dto) {
    // ... persistance
    publisher.publishEvent(new Envelope<>(
      Contexts.snapshot(), "PARTY_UPDATED", new PartyUpdated(partyId, dto.changes())));
  }
}
```

### 7) Listeners Audit (AOP + Event)
**Annotation & Aspect (survivre aux rollbacks via NEW TX)**
```java
@Target(METHOD) @Retention(RUNTIME)
public @interface Audited { String action(); String subjectType() default ""; String subjectIdExpr() default ""; }

@Aspect @Component
class AuditedAspect {
  private final AuditService audit; private final SalesforceOutboxService sf;

  @Around("@annotation(a)")
  Object around(ProceedingJoinPoint pjp, Audited a) throws Throwable {
    var ctx = Contexts.snapshot();
    try { return pjp.proceed(); }
    catch (Exception ex) {
      audit.recordErrorNewTx(ctx, a.action(), subjectFrom(pjp, a), ex);
      sf.enqueueNewTx("AuditError", payload(ctx, a, ex));
      throw ex;
    }
  }
}
```

**Listener Modulith (r√©installation contexte)**
```java
@Component
class AuditListener {
  private final AuditService audit; private final SalesforceOutboxService sf;

  @Async("auditExecutor")
  @ApplicationModuleListener
  void on(Envelope<PartyUpdated> e) {
    runWithSecurityAndMdc(e.ctx(), () -> {
      try {
        audit.recordInfoNewTx(e.ctx(), e.type(), "Party", e.payload().partyId(), toJson(e.payload()));
      } catch (Exception ex) {
        audit.recordErrorNewTx(e.ctx(), e.type(), "Party", e.payload().partyId(), ex);
        sf.enqueueNewTx("AuditError", Map.of(
          "correlationId", e.ctx().correlationId(),
          "userId", e.ctx().userId(),
          "tenantId", e.ctx().tenantId(),
          "eventType", e.type(),
          "partyId", e.payload().partyId(),
          "message", ex.getMessage()));
        throw ex; // laisser la publication incompl√®te pour retry
      }
    });
  }
}
```

### 8) Persistance (REQUIRES_NEW)
```java
@Service
class AuditService {
  private final AuditEntryRepository repo; private final Logger auditLogger = LoggerFactory.getLogger("AUDIT");

  @Transactional(propagation = REQUIRES_NEW)
  public void recordInfoNewTx(AuditContext ctx, String evt, String st, String sid, JsonNode payload) {
    var entry = new AuditEntry(Instant.now(), evt, "INFO", st, sid, ctx, payload);
    repo.save(entry); auditLogger.info(structured(entry));
  }

  @Transactional(propagation = REQUIRES_NEW)
  public void recordErrorNewTx(AuditContext ctx, String evt, String st, String sid, Exception ex) {
    var payload = toJson(Map.of("error", ex.getMessage()));
    var entry = new AuditEntry(Instant.now(), evt, "ERROR", st, sid, ctx, payload);
    repo.save(entry); auditLogger.warn(structured(entry));
  }
}
```

### 9) Int√©gration Salesforce (Outbox)
- **Why** : d√©coupler et garantir la livraison m√™me si Salesforce est indisponible.
- **Comment** : table `salesforce_outbox` + job `@Scheduled` pour flush avec retries.

```java
@Component
class SalesforceOutboxJob {
  @Scheduled(fixedDelay = 15000)
  @Transactional
  public void flush() { /* lockNextBatch -> sender -> markSent/Failed */ }
}
```

### 10) Logging Structur√© ‚Üí ELK/OpenSearch
- **Logback** : appender JSON (Logstash TCP/HTTP).
- **Cl√©s ECS-like** : `event.type`, `user.id`, `tenant.id`, `trace.correlation_id`, `audit=true`.
- **Dashboards** : Activity, Sensitive Changes, Error‚ÜíAudit par `correlation_id`.

### 11) S√©curit√©, PII & R√©tention
- **RBAC** : `AUDIT_READ` / `AUDIT_WRITE`.
- **Masquage PII** : `PayloadRedactor` (regex/annotations `@Sensitive`).
- **R√©tention** : purge DB (90j) + ISM/ILM index c√¥t√© OpenSearch (12‚Äì36 mois).
- **Immutabilit√©** : pas d‚ÄôUPDATE, uniquement INSERT.

### 12) Tests & Op√©rations
- **Unitaires** : Aspect, Contexts.snapshot, Redactor.
- **Modulaires** : `@ApplicationModuleListener` + Publication Registry retry.
- **Contrats** : API audit.
- **Charge** : batch insert, appender JSON.
- **Runbook** :
  - v√©rifier publications incompl√®tes Modulith,
  - relancer listeners,
  - surveiller outbox Salesforce (FAILED/attempts),
  - dashboards ELK (latence, volume, erreurs).

---

## üá¨üáß Part B ‚Äî Specification (EN)

### 1) Goals & Constraints
- **Trace** domain/app events, sensitive operations, critical errors.
- **Scope**: in‚Äëapp audit (local DB) + **structured logs** to ELK/OpenSearch.
- **Salesforce on error**: if audit fails, enqueue **Salesforce outbox** (retriable).
- **Spring Modulith**: events **AFTER_COMMIT** + **Publication Registry** for retries.
- **Context**: preserve user/roles/tenant/correlation across **async & retries**.
- **Compliance**: PII masking, logical immutability, retention, RBAC.

### 2) Modular Architecture (Spring Modulith)
_Identical to FR section; see module list above._

### 3) Data Model
_See FR SQL. Replace types if using PostgreSQL/others._

### 4) Contracts (Core)
_See FR `AuditContext`, `AuditEntry`, `Envelope<T>`._

### 5) Context Propagation (Web ‚Üí Async ‚Üí Retry)
- Take a **snapshot** at emission time.
- **Embed** `AuditContext` in every event.
- **Reinstall** SecurityContext + MDC in listeners.
- Use `DelegatingSecurityContextAsyncTaskExecutor` + MDC `TaskDecorator`.

### 6) Event Emission (After Commit)
_Same pattern as FR._

### 7) Audit Listeners (AOP + Event)
- **AOP** to catch failures and write audit/outbox in **`REQUIRES_NEW`**.
- **Event listener** restores context from envelope; throws on failure to keep publication **incomplete** for retry.

### 8) Persistence (REQUIRES_NEW)
- Separate transaction ensures audit survives business rollbacks and listener failures.

### 9) Salesforce Integration (Outbox)
- Durable, decoupled delivery with scheduled retries and circuit breaker.

### 10) Structured Logging ‚Üí ELK/OpenSearch
- Logback JSON appender; ECS-like keys; ready-to-use dashboards.

### 11) Security, PII, Retention
- RBAC, masking/redaction, retention policies, no updates on audit rows.

### 12) Testing & Ops
- Unit, modular, contract, load.
- Runbook for Modulith incomplete publications & Salesforce outbox.

---

## üì¶ Annexes ‚Äî Snippets & Config

### A. `logback-spring.xml` (extrait)
```xml
<configuration>
  <appender name="LOGSTASH" class="net.logstash.logback.appender.LogstashTcpSocketAppender">
    <destination>logstash:5044</destination>
    <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder"/>
  </appender>
  <logger name="AUDIT" level="INFO" additivity="false">
    <appender-ref ref="LOGSTASH"/>
  </logger>
</configuration>
```

### B. Checklist de Mise en ≈íuvre
- [ ] Snapshot de contexte √† l‚Äô√©mission.
- [ ] Enveloppe avec `AuditContext`.
- [ ] Listener ‚Üí r√©installer contexte.
- [ ] √âcritures audit + outbox en `REQUIRES_NEW`.
- [ ] Appender JSON vers ELK/OpenSearch.
- [ ] PII redaction + RBAC.
- [ ] R√©tention DB + ILM/ISM indices.
- [ ] Tests retry Publication Registry.
- [ ] Dashboards pr√™ts (Activity, Sensitive, Errors).

### C. Variantes
- **Table par module** si ownership strict.
- **CDC (Debezium)** pour ingestion vers data lake.
- **Chiffrement colonne** pour `payload_json` si requis.

---

> **Livrables fournis ici** : plan FR/EN, contrats, patterns (events, AOP, async), snippets cl√©s. √Ä adapter √† vos conventions de package et de nommage.



---

## ‚úçÔ∏è Documentation d√©taill√©e du code (FR)

### üîé Politique AOP ‚Äî faut‚Äëil logger aussi en cas de succ√®s ?
**Recommandation par d√©faut (contexte Spring Modulith + Publication Registry)** :
- **AOP = √©chec uniquement** (moins de bruit, pas de faux positifs si la Tx rollback ensuite).
- **Succ√®s = via √©v√©nements after‚Äëcommit** (garantis seulement lorsque la Tx a effectivement **commit**).

**Alternatives (si besoin m√©tier)** :
1) **AOP succ√®s + √©chec** mais **d√©f√©r√© apr√®s outcome** : on √©crit l‚Äôaudit depuis l‚ÄôAOP **apr√®s** avoir su si la Tx a commit/rollback, via `TransactionSynchronization.afterCompletion(...)`, et on persiste en `REQUIRES_NEW`.
2) **Flag par annotation** : `@Audited(logOnSuccess = true)` active ce mode uniquement sur certaines m√©thodes.

```java
@Target(METHOD)
@Retention(RUNTIME)
public @interface Audited {
  String action();
  String subjectType() default "";
  String subjectIdExpr() default ""; // ex: "#partyId"
  boolean logOnSuccess() default false; // ‚áê optionnel : succ√®s via AOP
}

@Aspect @Component
class AuditedAspect {
  private final AuditService audit; private final SalesforceOutboxService sf;

  @Around("@annotation(a)")
  Object around(ProceedingJoinPoint pjp, Audited a) throws Throwable {
    var ctx = Contexts.snapshot();
    var subjectType = a.subjectType();
    var subjectId   = evalSubjectId(pjp, a.subjectIdExpr());

    // Si on veut aussi tracer le succ√®s via AOP, s‚Äôabonner au cycle Tx
    if (a.logOnSuccess()) {
      TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() {
        @Override public void afterCompletion(int status) {
          if (status == STATUS_COMMITTED) {
            audit.recordInfoNewTx(ctx, a.action(), subjectType, subjectId, json(Map.of("aop","success")));
          }
        }
      });
    }

    try {
      return pjp.proceed();
    } catch (Exception ex) {
      audit.recordErrorNewTx(ctx, a.action(), subjectType, subjectId, ex); // survit au rollback
      sf.enqueueNewTx("AuditError", Map.of(
        "correlationId", ctx.correlationId(),
        "userId", ctx.userId(),
        "tenantId", ctx.tenantId(),
        "action", a.action(),
        "subjectType", subjectType,
        "subjectId", subjectId,
        "message", ex.getMessage()
      ));
      throw ex;
    }
  }
  // ... evalSubjectId(...) identique
}
```

> **TL;DR** : garde **AOP pour les erreurs** (fiable, sobre). Si un besoin impose le succ√®s via AOP, utilise **afterCompletion** pour n‚Äô√©crire qu‚Äôapr√®s connaissance de l‚Äôissue, et toujours en **`REQUIRES_NEW`**.

### A) Annotation & Aspect AOP ‚Äî *loguer uniquement en cas d‚Äôerreur*
> **But** : ne pas ¬´ bruiter ¬ª l‚Äôaudit en AOP. L‚ÄôAOP ne **loggue** qu‚Äôen **√©chec**, pour garantir une trace m√™me si la transaction m√©tier a rollback. Les **succ√®s** sont g√©r√©s par les **√©v√©nements** (listeners apr√®s commit) afin de rester modulaires et coh√©rents avec Spring Modulith.

```java
/**
 * Marque une m√©thode comme sensible du point de vue audit.
 * - action: nom canonique de l‚Äôaction (ex: "UPDATE_PARTY")
 * - subjectType: type logique de la cible (ex: "Party")
 * - subjectIdExpr: SpEL pour extraire l‚Äôidentifiant (ex: "#partyId")
 */
@Target(METHOD)
@Retention(RUNTIME)
public @interface Audited {
  String action();
  String subjectType() default "";
  String subjectIdExpr() default ""; // ex: "#partyId"
}

/**
 * Aspect d‚Äôaudit minimaliste.
 *
 * ‚úî Capture un snapshot du contexte (user/roles/tenant/correlationId).
 * ‚úî Si la m√©thode √©choue, √©crit un audit **en nouvelle transaction** (REQUIRES_NEW)
 *   pour survivre au rollback m√©tier + enfile un message outbox Salesforce.
 * ‚úñ Ne loggue rien en cas de succ√®s (on laisse les events le faire apr√®s commit).
 */
@Aspect
@Component
class AuditedAspect {
  private final AuditService audit;            // persistance audit en NEW TX
  private final SalesforceOutboxService sf;    // outbox Salesforce en NEW TX
  private final SpelExpressionParser spel = new SpelExpressionParser();

  AuditedAspect(AuditService audit, SalesforceOutboxService sf) {
    this.audit = audit; this.sf = sf;
  }

  @Around("@annotation(a)")
  Object around(ProceedingJoinPoint pjp, Audited a) throws Throwable {
    var ctx = Contexts.snapshot(); // user/roles/tenant/correlationId/requestId
    String subjectType = a.subjectType();
    String subjectId   = evalSubjectId(pjp, a.subjectIdExpr());

    try {
      return pjp.proceed();
    } catch (Exception ex) {
      // 1) √âcriture d‚Äôaudit d‚Äôerreur en **nouvelle transaction**
      audit.recordErrorNewTx(ctx, a.action(), subjectType, subjectId, ex);

      // 2) Outbox Salesforce (rejouable, d√©coupl√©)
      sf.enqueueNewTx("AuditError", Map.of(
        "correlationId", ctx.correlationId(),
        "userId", ctx.userId(),
        "tenantId", ctx.tenantId(),
        "action", a.action(),
        "subjectType", subjectType,
        "subjectId", subjectId,
        "message", ex.getMessage()
      ));

      // 3) Propager l‚Äôerreur pour que l‚Äôappelant sache qu‚Äôil y a √©chec
      throw ex;
    }
  }

  private String evalSubjectId(ProceedingJoinPoint pjp, String expr) {
    if (expr == null || expr.isBlank()) return null;
    var method = ((MethodSignature) pjp.getSignature()).getMethod();
    var ctx = new StandardEvaluationContext(new MethodBasedEvaluationContext(null, method, pjp.getArgs(), new DefaultParameterNameDiscoverer()));
    var parsed = spel.parseExpression(expr);
    var val = parsed.getValue(ctx);
    return (val != null ? String.valueOf(val) : null);
  }
}
```

**Pourquoi ce choix ?**
- En **succ√®s**, la v√©rit√© vient des **√©v√©nements apr√®s commit** (Publication Registry + retries). 
- En **√©chec**, seule l‚ÄôAOP, d√©clench√©e *dans le flot de l‚Äôexception*, peut garantir un **audit persistant** (NEW TX) + un **signal Salesforce**.

---

### B) Listeners d‚Äô√©v√©nements ‚Äî *succ√®s apr√®s commit, retries g√©r√©s par Modulith*

```java
/** Ev√©nement envelopp√© avec le contexte d‚Äôaudit fig√© au moment de l‚Äô√©mission. */
public record Envelope<T>(AuditContext ctx, String type, T payload) {}

/** Exemple d‚Äô√©mission dans une transaction m√©tier. */
@Service
class PartyService {
  private final ApplicationEventPublisher publisher;
  @Transactional
  public void updateParty(String partyId, UpdateDto dto) {
    // ... persistance JPA
    publisher.publishEvent(new Envelope<>(
      Contexts.snapshot(), "PARTY_UPDATED", new PartyUpdated(partyId, dto.changes())));
  }
}

/** Listener asynchrone : restaure le contexte et √©crit en NEW TX. */
@Component
class AuditListener {
  private final AuditService audit; private final SalesforceOutboxService sf;

  @Async("auditExecutor")
  @ApplicationModuleListener
  void on(Envelope<PartyUpdated> e) {
    runWithSecurityAndMdc(e.ctx(), () -> {
      try {
        audit.recordInfoNewTx(e.ctx(), e.type(), "Party", e.payload().partyId(), toJson(e.payload()));
      } catch (Exception ex) {
        // Echec du listener => garder publication incompl√®te (retry) **et** tracer l‚Äô√©chec
        audit.recordErrorNewTx(e.ctx(), e.type(), "Party", e.payload().partyId(), ex);
        sf.enqueueNewTx("AuditError", Map.of(
          "correlationId", e.ctx().correlationId(),
          "userId", e.ctx().userId(),
          "tenantId", e.ctx().tenantId(),
          "eventType", e.type(),
          "partyId", e.payload().partyId(),
          "message", ex.getMessage()
        ));
        throw ex; // permet √† Spring Modulith de rejouer plus tard
      }
    });
  }
}
```

---

## üóÉÔ∏è Mod√®le de donn√©es ‚Äî Documentation (FR)

### Table `audit_entry`
**R√¥le** : journal applicatif persistant et immuable (INSERT‚Äëonly). Les succ√®s proviennent surtout des **listeners after‚Äëcommit** ; les erreurs peuvent venir de l‚Äô**AOP** (NEW¬†TX) ou des listeners.

| Colonne | Type | Obligatoire | Exemple | Contraintes/Notes |
|---|---|---:|---|---|
| `id` | NUMBER (IDENTITY) | ‚úî | `102934` | PK technique ; pas r√©utilis√©e. |
| `ts_utc` | TIMESTAMP WITH TIME ZONE | ‚úî | `2025-09-25T10:11:12Z` | Utiliser `Clock` pour tests ; index√©. |
| `event_type` | VARCHAR2(128) | ‚úî | `PARTY_UPDATED` | Nommage constant (enum/const) ; index√©. |
| `severity` | VARCHAR2(16) | ‚úî | `INFO`/`ERROR` | Valeurs : `INFO`,`WARN`,`ERROR`,`SECURITY`. |
| `user_id` | VARCHAR2(128) |  | `alice` | `anonymous` si inconnu ; ne pas stocker PII non n√©cessaire. |
| `roles` | VARCHAR2(512) |  | `ROLE_ADMIN,ROLE_USER` | Peut √™tre JSON si besoin multi‚Äëvaleurs riche. |
| `tenant_id` | VARCHAR2(64) |  | `lux` | Pour routing multi‚Äëtenant et filtres Kibana. |
| `correlation_id` | VARCHAR2(128) |  | `c-2d1f...` | Propag√© via MDC ; **cl√© de jointure** avec logs applicatifs. |
| `request_id` | VARCHAR2(128) |  | `r-9ab7...` | Granularit√© intra‚Äërequ√™te ; utile en debug. |
| `source` | VARCHAR2(64) |  | `API`/`EVENT` | Origine : `API`/`SERVICE`/`EVENT`/`BATCH`/`KAFKA`‚Ä¶ |
| `subject_type` | VARCHAR2(128) |  | `Party` | Type m√©tier vis√© ; utile pour pivot. |
| `subject_id` | VARCHAR2(256) |  | `P12345` | Identifiant m√©tier cible ; attention aux tailles. |
| `payload_json` | CLOB (JSON) | ‚úî | `{ "oldRole":"CLIENT","newRole":"THIRD_PARTY" }` | **Redaction PII** obligatoire ; rester concis. |
| `signature_hash` | VARCHAR2(128) |  | `HMAC-SHA256(...)` | Int√©grit√© optionnelle (HMAC sur payload+meta). |

**Index conseill√©s**
- `(ts_utc)` pour les recherches temporelles.
- `(event_type)` pour les filtres fonctionnels.
- `(correlation_id)` pour la corr√©lation.
- Facultatif : `(tenant_id, ts_utc)` si multi‚Äëtenant volumineux.

**Idempotence (option)**
- Contrainte logique `(event_type, subject_id, request_id)` si rejouabilit√© possible.

**PII & s√©curit√©**
- Masquer/√©liminer les PII dans `payload_json` (`PayloadRedactor`).
- Ne journaliser que ce qui est **utile** au support et √† la conformit√©.

### Table `salesforce_outbox`
**R√¥le** : file durable pour notifier Salesforce des erreurs (ou signaux d‚Äôaudit critiques) avec retries.

| Colonne | Type | Obligatoire | Exemple | Notes |
|---|---|---:|---|---|
| `id` | NUMBER (IDENTITY) | ‚úî | `7781` | PK |
| `created_at` | TIMESTAMPTZ | ‚úî | `2025-09-25T10:11:30Z` | Rollover et m√©triques de d√©lai. |
| `type` | VARCHAR2(64) | ‚úî | `AuditError` | Type logique stable pour mapping SF. |
| `payload_json` | CLOB (JSON) | ‚úî | `{ ... }` | Minimal, actionnable (corrId, message, ids). |
| `status` | VARCHAR2(16) | ‚úî | `NEW` | Enum : `NEW`/`SENT`/`FAILED`; index√©. |
| `attempts` | NUMBER | ‚úî | `3` | Pour backoff exponentiel. |
| `last_error` | CLOB |  | `Timeout` | Derni√®re raison d‚Äô√©chec.

**Flux**
1) `enqueueNewTx(...)` ins√®re.
2) `@Scheduled` lit `status=NEW` par lot.
3) Envoi ‚Üí `SENT` ou `FAILED`; plan de retry.

## üá¨üáß Notes (EN) ‚Äî What changed vs. previous version
- Added **AOP policy** (error‚Äëonly by default, optional success via `afterCompletion`).
- Expanded **column‚Äëlevel documentation** with examples, constraints and indexing hints.

---

## üìã Checklist & Examples (FR/EN)

### FR ‚Äî Checklist op√©rationnelle
- [x] **Contexts.snapshot()** capture `userId`, `roles`, `tenantId`, `correlationId`, `requestId`.
- [x] **Envelope<T>** embarque `AuditContext` pour chaque √©v√©nement.
- [x] **Succ√®s** via **listeners after‚Äëcommit** (`@ApplicationModuleListener`) + **REQUIRES_NEW**.
- [x] **Erreurs** via **AOP** (`@Audited`) ‚áí **REQUIRES_NEW** + **Salesforce outbox**.
- [x] **Async** : `DelegatingSecurityContextAsyncTaskExecutor` + `TaskDecorator` MDC.
- [x] **Retry Modulith** : ne pas d√©pendre du `SecurityContext` thread‚Äëlocal, utiliser `Envelope.ctx()`.
- [x] **PII** : redaction avant persistance et logging.
- [x] **Indices** sur `ts_utc`, `event_type`, `correlation_id`.

### EN ‚Äî Operational checklist
- [x] **Contexts.snapshot()** captures `userId`, `roles`, `tenantId`, `correlationId`, `requestId`.
- [x] **Envelope<T>** embeds `AuditContext` into each event.
- [x] **Success** via **after‚Äëcommit listeners** + **REQUIRES_NEW** writes.
- [x] **Failures** via **AOP** (`@Audited`) ‚áí **REQUIRES_NEW** + **Salesforce outbox**.
- [x] **Async**: `DelegatingSecurityContextAsyncTaskExecutor` + MDC `TaskDecorator`.
- [x] **Modulith retry**: never rely on thread‚Äëlocal `SecurityContext`; use `Envelope.ctx()`.
- [x] **PII**: redact before persisting & logging.
- [x] **Indexes**: `ts_utc`, `event_type`, `correlation_id`.

### Exemples minimaux

**1) √âmission envelopp√©e (succ√®s)**
```java
publisher.publishEvent(new Envelope<>(
  Contexts.snapshot(),
  "PARTY_UPDATED",
  new PartyUpdated(partyId, dto.changes())
));
```

**2) Listener (succ√®s) ‚Äî restauration du contexte**
```java
@ApplicationModuleListener
@Async("auditExecutor")
void on(Envelope<PartyUpdated> e) {
  runWithSecurityAndMdc(e.ctx(), () ->
    audit.recordInfoNewTx(e.ctx(), e.type(), "Party", e.payload().partyId(), toJson(e.payload()))
  );
}
```

**3) AOP (erreur) ‚Äî √©criture NEW TX + outbox**
```java
@Audited(action="UPDATE_PARTY", subjectType="Party", subjectIdExpr="#partyId")
public void updateParty(String partyId, UpdateDto dto) { /* ... peut lever */ }
```

---

## üß© `Contexts.snapshot()` ‚Äî Helper central (FR/EN)

**FR ‚Äî R√¥le** : capturer le contexte d‚Äôex√©cution courant pour le porter dans les √©v√©nements et pouvoir le r√©‚Äëutiliser en async/retry.

**EN ‚Äî Purpose**: capture current execution context to be embedded in events and reused during async/retries.

```java
public final class Contexts {
  private Contexts() {}

  public static AuditContext snapshot() {
    var auth = SecurityContextHolder.getContext().getAuthentication();
    String userId = (auth != null ? auth.getName() : "anonymous");
    List<String> roles = (auth != null)
      ? auth.getAuthorities().stream().map(a -> a.getAuthority()).toList()
      : List.of();

    String tenantId      = MDC.get("tenantId");
    String correlationId = MDC.get("correlationId");
    String requestId     = MDC.get("requestId");

    return new AuditContext(userId, roles, tenantId, correlationId, requestId);
  }
}
```

**Usage**
```java
publisher.publishEvent(new Envelope<>(Contexts.snapshot(), "EVENT_TYPE", payload));
```

**Pourquoi / Why**
- FR : `SecurityContext`/MDC sont des ThreadLocals ; en retry, ils sont vides. L‚Äôenveloppe garde l‚Äôidentit√© & corr√©lation.
- EN : ThreadLocals vanish on retries; the envelope preserves identity & correlation.

