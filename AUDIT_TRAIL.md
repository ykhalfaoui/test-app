# Audit Trail (Spring Modulith) — Minimal, Correct, and Searchable

## Goals
- Capture **who/what/when** for important actions and errors with **low noise**.
- Guarantee logs on **success (after commit)** and **failure (even on rollback)**.
- Make entries **queryable** in DB and **searchable** in ELK/OpenSearch using structured logs.
- Avoid sensitive-data leakage and follow **logging best practices**.

---

## TL;DR (Design)
- **Success path**: publish application/domain events; handle with `@TransactionalEventListener(phase = AFTER_COMMIT)` so they run only after DB commit.
- **Failure path**: AOP around sensitive services; on exception, write audit **in a new transaction** (survives rollback) and enqueue a **Salesforce outbox** entry for alerting.
- **Context**: take a **snapshot** (user, roles, tenant, correlationId, requestId) at emission time and carry it in the event payload; reinstall in async listeners.
- **Structured logging**: emit JSON to logs and map fields to **ECS** (`@timestamp`, `event.type`, `user.*`, `trace.id`/correlation).
- **Sanitization**: follow **OWASP** logging guidance (redact/avoid PII).

---

## Minimal Data Model (DB)
```sql
CREATE TABLE audit_entry (
  id             BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ts_utc         TIMESTAMP WITH TIME ZONE NOT NULL,
  event_type     VARCHAR(120)        NOT NULL,
  severity       VARCHAR(12)         NOT NULL,
  actor_id       VARCHAR(120),
  tenant_id      VARCHAR(64),
  correlation_id VARCHAR(128),
  request_id     VARCHAR(128),
  subject_type   VARCHAR(120),
  subject_id     VARCHAR(256),
  source         VARCHAR(32),
  details_json   JSON NOT NULL
);
CREATE INDEX idx_audit_ts   ON audit_entry(ts_utc);
CREATE INDEX idx_audit_evt  ON audit_entry(event_type);
CREATE INDEX idx_audit_corr ON audit_entry(correlation_id);
```

### Why this shape?
- Mirrors **ECS** fields for ingestion (`@timestamp`, `event.type`, `user.id`, `trace.id`).
- Minimal columns → fewer schema migrations and less risk of leaking PII (extra info in `details_json`, redacted).

---

## Success vs Failure

### Success (after commit, replayable)
```java
@Transactional
public void updateParty(...) {
  publisher.publishEvent(new Envelope<>(
     Contexts.snapshot(), "PARTY_UPDATED", new PartyUpdated(partyId)));
}

@Async("auditExecutor")
@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
public void on(Envelope<PartyUpdated> e) {
  withSecurityAndMdc(e.ctx(), () -> auditService.recordInfoNewTx(
    e.ctx(), e.type(), "Party", e.payload().partyId(), toJson(e.payload())));
}
```

### Failure (immediate, survives rollback)
```java
@Around("@annotation(audited)")
Object around(ProceedingJoinPoint pjp, Audited audited) throws Throwable {
  var ctx = Contexts.snapshot();
  try {
    return pjp.proceed();
  } catch (Exception ex) {
    auditService.recordErrorNewTx(ctx, audited.action(), audited.subjectType(),
                                  evalSubjectId(pjp, audited.subjectIdExpr()), ex);
    salesforceOutbox.enqueueNewTx("AuditError", Map.of(
      "correlationId", ctx.correlationId(), "userId", ctx.userId(),
      "tenantId", ctx.tenantId(), "action", audited.action(), "message", ex.getMessage()));
    throw ex;
  }
}
```

---

## Context Snapshot Helper
```java
public final class Contexts {
  public static AuditContext snapshot() {
    var auth = SecurityContextHolder.getContext().getAuthentication();
    var user  = auth != null ? auth.getName() : "anonymous";
    var roles = auth != null ? auth.getAuthorities().stream().map(a -> a.getAuthority()).toList() : List.of();
    return new AuditContext(user, roles, MDC.get("tenantId"),
                            MDC.get("correlationId"), MDC.get("requestId"));
  }
}
```

---

## Business Log (after commit)
- Use `@TransactionalEventListener(AFTER_COMMIT)` and pass **entity ID** + context in the event.
- In the listener, reload the entity or include a redacted snapshot prepared before commit.
- Hibernate post-commit listeners are possible but couple you to ORM internals.

---

## Structured Logs → ELK/OpenSearch
- Emit JSON logs aligned with ECS: `@timestamp`, `event.type`, `user.id`, `trace.id`.
- Keep payloads **small and redacted**.
- Use correlationId for joins across logs.

---

## Quick Checklist
- [x] Minimal table with stable fields only.
- [x] Success → after-commit listener, replayable.
- [x] Failure → AOP in `REQUIRES_NEW` + Salesforce outbox.
- [x] Always snapshot context at emission.
- [x] Structured logs aligned with ECS.
- [x] Redact PII before persisting/logging.
